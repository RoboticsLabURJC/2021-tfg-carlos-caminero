---
title: "Semana 3. Docker y ROS Bridge"
categories:
  - Etapa de Entrenamiento
  - Octubre
tags:
  - ROS 2
  - Docker
---

La semana 3 consistió en diseñar una imagen Docker para poder ejecutar sobre el robot real Turtlebot2 un contenedor con ROS 2 Foxy y los drivers kobuki instalados, junto con la capacidad de lanzar el nodo operador Keyop para controlar manualmente el robot.

Para ello creé un fichero [**Dockerfile**](https://github.com/RoboticsLabURJC/2021-tfg-carlos-caminero/blob/main/training_stage/kobuki/kobuki_control_docker/Dockerfile) donde especifique las instrucciones para el proceso de contrucción de la imagen.

La sintaxis que empleé es sencilla:
* Con **FROM** seleccionamos una imagen base.
* Con **ARG** creamos variables existentes unicamente en el proceso de construcción.
* Con **RUN** ejecutamos instrucciones durante el proceso de construcción(en este caso, instrucciones Unix con intérprete sh) desde el **WORKDIR** (por defecto, "/").
* Con **CMD** indicamos el comando inicial por defecto que se ejecutará siempre que lanzemos el contenedor (usando docker run). Solo puede haber uno.

Hay más sintaxis (**COPY**, **ENV**, **WORKDIR**, etc.), pero es sencillo de usar. Contar con conocimientos en Unix proporcinan una ventaja muy grande a la hora de desarrollar imágenes Docker.

Para lanzar el contenedor, recomiendo ejecutar el script [**run_docker**](https://github.com/RoboticsLabURJC/2021-tfg-carlos-caminero/blob/main/training_stage/kobuki/kobuki_control_docker/run_docker).
Si la imagen no esta instalada en la máquina local, se ejecutará automáticamente el comando **docker pull**.

En el lanzamiento del contenedor usé el sistema de ventanas X de Unix, para lanzar un terminal xterm externo y tomar el control del nodo **keyop**.
~~~
xhost +
docker run -it --rm -e DISPLAY=$DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix carlosalpha1/kobuki_keyop:ros-foxy
xhost -
~~~

